函数是对象的一种，通过new调用构造方法构造一个新的函数，对象类型都具有属性和方法。

**函数的作用域**

每个函数都有自己的作用域，但是函数的作用域并不是在花括号之间，而是花括号和小括号的并集。





**函数的this指向**

1.默认的this指向

大多数函数是直接运行而不是被其他函数或者任何对象调用，这时的this指向全局，也就是window，因为window是该函数的调用者。

2.显式绑定

显示绑定顾名思义就是直接要求某个对象来接管该函数，该函数的this也就绑定到了指定的对象身上，通过apply、call、bind方法实现。

```
apply、call、bind方法功能相似，都是一个对象成为另一个对象属性与方法的使用者，假设a具有许多方法，b没有某方法但是想要使用该方法，就可以明面上执行a（），实际上再用apply、call、bind方法将调用者变成b，此时a中原本指向自身或者全局的this就变成指向b，b就可以使用a中的方法了。
三者的主要区别还是传参的区别，三者传入的第一个参数都是this重新绑定的对象，从第二个参数起，apply只能传入一个数组，而call和bind则是一个个参数依次用逗号隔开。bind和call的区别是bind的回调是一个函数。
```

3.隠式绑定

隠式绑定是不知道this指向谁，要根据上下文信息判断。这种判断的总结就是两点，第一，函数的执行位置是不是在某个或多个对象之后充当其方法的位置，如果是的话this就指向调用其的最近的对象。第二，如果是在某个块级作用域中，那么就会一直向上寻找，直到找到一个函数或者对象作为this的指向为止。两种情况都满足就近原则。

```
var a = 1
function foo(){
  console.log(this.a)
}
var obj = {
  a:123,
  foo:foo
}
var obj2 = {
  a:123123,
  foo:foo,
  obj:{
    a:123,
    foo:foo
  }
}

foo() //全局中执行
obj.foo() //在某个对象之后充当方法被执行
obj2.obj.foo() //在多层对象中充当方法被执行时究竟是就近原则还是冒泡原则？
{
  a = 1
  {
    a = 2
    foo()
    {
      a = 3
      foo()
    }
  }
}
```

![image-20200820154752145](C:\Users\shiku\AppData\Roaming\Typora\typora-user-images\image-20200820154752145.png)

多说一嘴，块级作用域相对比较麻烦，因为在这里的this和this.a指向是不一样的，网上有的总结，“this指向自身”，“this指向函数作用域”等等都是不完整的，最靠谱的应该是this指向调用者，能够调用一个函数的不外乎对象、函数、window，而作用域并不是任何一种，typeof作用域是会报错的，所以作用域无法被当成this指向，而this的属性指向则不同，属性并不需要调用者，属性是从距离最近的作用域开始，逐级向上查找，直到找到为止。

4.构造器this指向

“this指向自身的起源”（猜测），this指向被构造出来的对象或者函数，然而本质还是因为构造出来的是个对象或者函数，所以没什么稀奇的（笑）

5.各种this指向的优先级

由demo易得 构造器绑定 > 显示绑定 > 隠式绑定 > 默认绑定

```
还有一些小问题，思考一种情况：
var index = 0

function foo(){
  console.log(this.index)
}

var a = {
  index:1,
  foo
}

var c = a.foo
c()

原本a.foo得到结果1是令人满意的，现在我希望a.foo能够封装成一个c，这样只需要执行c就可以了，但是c的执行结果却变成this指向全局对象，变成是默认绑定了。这是this隠式绑定才会出现的隠式丢失，问题出在赋值上，赋值是把a.foo的地址传递给c，而不是a.foo连同a也传递给c，所以单单拿了引用的c，最终成为了foo的调用者，this指向调用者。
```
